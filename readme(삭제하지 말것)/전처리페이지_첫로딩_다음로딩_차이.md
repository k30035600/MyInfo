# 은행거래/신용카드 전처리 페이지: 첫 로딩 vs 다음 로딩 (JSON·캐시 읽기 방식)

## 요약

- **첫 로딩**: 디스크 I/O 다수(엑셀·JSON 읽기/쓰기) + 필요 시 통합·전처리 실행 → **느림**
- **다음 로딩**: 메모리 캐시만 사용(디스크 읽기 없음) → **빠름**

속도 차이는 **캐시 미적용 시 디스크 접근**과 **캐시 적용 시 메모리만 사용**하기 때문입니다.

---

## 1. 페이지가 호출하는 API (공통)

전처리 페이지 진입 시 프론트는 대략 다음 순서로 요청합니다.

| API | 용도 | 은행 | 신용카드 |
|-----|------|------|----------|
| `/api/source-data` | 전처리전 테이블 | ✅ | ✅ |
| `/api/processed-data` | 전처리후 테이블 | ✅ | ✅ |
| `/api/category-applied-data` | 카테고리 적용후 테이블 | ✅ | ✅ |

(은행은 `loadLeftData` → source-data, `loadRightData` → processed-data, 카테고리 적용후 탭 → category-applied-data.)

---

## 2. 은행거래 (MyBank)

### 사용하는 캐시

| 캐시 변수 | 내용 | 무효화 시점 |
|-----------|------|-------------|
| `_source_bank_cache` | .source/Bank 엑셀을 읽어 만든 전처리전 데이터(리스트) | 전처리/후처리 재생성 버튼 |
| `_bank_before_cache` | bank_before.json을 읽어 만든 DataFrame | 전처리/후처리 재생성 버튼 |
| `_bank_after_cache` | bank_after.json을 읽어 만든 DataFrame | 전처리/후처리 재생성 버튼 |

### 첫 로딩 (캐시 전부 비어 있음)

1. **GET /api/source-data**
   - `_source_bank_cache is None` → `_build_source_bank_cache()` 호출
   - **디스크**: `.source/Bank`의 모든 .xls/.xlsx 열기, 시트별 `pd.read_excel()` → 리스트로 보관 후 캐시에 저장
   - **느린 이유**: 엑셀 파일 열기·파싱이 무거움

2. **GET /api/processed-data**
   - `_bank_before_cache is None` → `ensure_bank_before_and_category()` 실행
     - bank_before.json 없/비면 **디스크**: .source/Bank 엑셀 읽기, 전처리, **bank_before.json 쓰기**
   - 이어서 `load_processed_file()` 호출
     - **디스크**: bank_before.json 읽기 (`safe_read_data_json`) → 캐시에 저장
   - **느린 이유**: 엑셀 읽기·전처리·JSON 쓰기·JSON 읽기

3. **GET /api/category-applied-data**
   - `_bank_after_cache is None` → `ensure_bank_before_and_category()` (이미 위에서 했으면 추가 작업 적음)
   - `load_category_file()` 호출
     - **디스크**: bank_after.json 읽기 (`safe_read_data_json`) → 캐시에 저장 (없으면 bank_before fallback)
   - **느린 이유**: JSON 파일 읽기

### 다음 로딩 (캐시 있음)

1. **GET /api/source-data**
   - `_source_bank_cache is not None` → 캐시 리스트에서 은행 필터만 적용해 반환
   - **디스크 접근 없음**

2. **GET /api/processed-data**
   - `_bank_before_cache is not None` → `ensure_*` 호출 안 함
   - `load_processed_file()` → `_bank_before_cache.copy()` 반환
   - **디스크 접근 없음**

3. **GET /api/category-applied-data**
   - `_bank_after_cache is not None` → `ensure_*` 호출 안 함
   - `load_category_file()` → `_bank_after_cache.copy()` 반환
   - **디스크 접근 없음**

---

## 3. 신용카드 (MyCard)

### 사용하는 캐시

| 캐시 변수 | 내용 | 무효화 시점 |
|-----------|------|-------------|
| `_source_card_cache` | .source/Card 엑셀을 읽어 만든 전처리전 데이터(리스트) | 전처리/후처리 재생성 버튼 |
| `_card_before_cache` | card_before.json 읽어 만든 DataFrame | 전처리/후처리 재생성 버튼 |
| `_card_after_cache` | card_after.json 읽어 만든 DataFrame | 전처리/후처리 재생성 버튼 |

### 첫 로딩 (캐시 비어 있음)

1. **GET /api/source-data**
   - `_source_card_cache is None` → `_build_source_card_cache()` 호출
   - **디스크**: .source/Card의 .xls/.xlsx 열기, 시트별 읽기 → 캐시에 저장
   - **느린 이유**: 엑셀 열기·파싱

2. **GET /api/processed-data**
   - card_before.json 없/비면 `_call_integrate_card()` 실행
     - **디스크**: .source/Card 엑셀 읽기, 통합·전처리, **card_before.json 쓰기**
   - `load_card_before_file()` 호출
     - **디스크**: card_before.json 읽기 → 캐시에 저장
   - **느린 이유**: 엑셀 읽기·통합·JSON 쓰기·JSON 읽기

3. **GET /api/category-applied-data**
   - `_load_card_after_cached()` → 캐시 없으면 **디스크**: card_after.json 읽기 → 캐시에 저장
   - **느린 이유**: JSON 읽기 (card_after가 없으면 생성 API는 별도)

### 다음 로딩 (캐시 있음)

- **GET /api/source-data**: `_source_card_cache`에서 필터만 적용, 디스크 없음
- **GET /api/processed-data**: `_card_before_cache`에서 반환, 디스크 없음 (파일 있으면 `_call_integrate_card`도 호출 안 함)
- **GET /api/category-applied-data**: `_card_after_cache`에서 반환, 디스크 없음

---

## 4. 왜 속도 차이가 큰가

| 구분 | 첫 로딩 | 다음 로딩 |
|------|---------|-----------|
| 전처리전(source) | .source 폴더 엑셀 **전부 디스크에서 읽기·파싱** | **메모리 캐시**에서 필터만 |
| 전처리후(before) | 엑셀 읽기 + 전처리 + JSON 쓰기 + **JSON 읽기** 또는 ensure 후 **JSON 읽기** | **메모리 캐시**만 사용 |
| 카테고리 적용후(after) | **JSON 읽기** (bank_after/card_after) | **메모리 캐시**만 사용 |

- 첫 로딩: **엑셀 I/O + JSON 쓰기/읽기**가 한 번씩 발생
- 다음 로딩: **캐시 히트**로 디스크 접근 없이 메모리만 사용

데이터가 클수록 JSON/엑셀 크기가 커져 첫 로딩이 더 느려지고, 다음 로딩은 캐시만 쓰므로 상대적으로 매우 빠릅니다.

---

## 5. 캐시가 비워지는 경우

- **전처리/후처리 재생성** 버튼 클릭 시: `_remove_*_before_after_and_bak()`에서 위 캐시 변수 전부 `None`으로 초기화
- **서버 재시작**: 프로세스가 끝나므로 모든 캐시 소멸

이후 첫 요청은 다시 “첫 로딩”과 동일하게 디스크에서 읽고 캐시를 채웁니다.
