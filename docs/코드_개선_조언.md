# 코드 개선 조언 (UX/UI 제외)

처음부터 실행·검토한 결과, 유지보수·안정성·일관성 측면에서 적용하면 좋은 개선 사항입니다.

---

## 1. API 일관성 및 오용 방지

### 1.1 `load_category_table` vs `get_category_table` 반환값 혼동
- **현재**: `load_category_table(path)` → **DataFrame 또는 None** (한 개 값)  
  `get_category_table(path)` → **(DataFrame, file_existed)** (튜플)
- **문제**: 호출부에서 `df, existed = load_category_table(p)`처럼 쓰면 `ValueError: too many values to unpack` 발생. 반환 형태가 달라 혼동하기 쉬움.
- **조언**:
  - 두 함수의 역할을 문서화하고, **“조회만 할 때는 `get_category_table`, 내부에서 df만 필요할 때는 `load_category_table`”** 정도로 사용 규칙을 정해 두기.
  - 또는 `load_category_table`에 `return_file_existed: bool = False` 인자를 두고, `True`일 때만 `(df, file_existed)`를 반환하도록 통일하는 방식도 검토 가능.

---

## 2. 중복 제거 (유지보수성)

### 2.1 `ensure_all_bank_files` vs `ensure_bank_before_and_category` ✅ 적용
- **적용 내용**: `_ensure_bank_before_and_category_only()` 내부 함수로 공통화. (아래 조언은 반영됨.)
- **현재(과거)**: 두 함수가 “bank_before 확인 → category_table.json 생성/복구/마이그레이션” 블록을 거의 동일하게 반복함. 차이는 마지막에 bank_after 생성 여부뿐.
- **조언**:  
  - “bank_before + category_table만 확보”하는 내부 함수 하나로 공통화하고,  
  - `ensure_all_bank_files()` = 그 함수 호출 후 필요 시 `classify_and_save()`로 bank_after 생성  
  - `ensure_bank_before_and_category()` = 그 함수만 호출  
  이렇게 하면 category_table 관련 로직 수정 시 한 곳만 고치면 됨.

### 2.2 `process_cash_data` / `process_card_data`의 ImportError 폴백
- **현재**: `category_table_io` 실패 시 각 모듈에서 긴 fallback 정의를 가짐. (이미 bank/cash/card 앱은 `category_table_fallback`으로 정리됨.)
- **조언**: `process_bank_data`, `process_cash_data` 등에서도 `except ImportError` 시 **`category_table_fallback`**을 사용하도록 통일하면, 폴백 로직이 한 곳에만 있어 유지보수가 쉬움.

---

## 3. 예외 처리 정교화

### 3.1 `except Exception` 후 무시
- **현재**: 많은 곳에서 `except Exception: pass` 또는 `except Exception: ... pass`로 모든 예외를 무시함. 디버깅 시 원인 파악이 어렵고, 잘못된 데이터/경로도 조용히 넘어갈 수 있음.
- **조언**:
  - 최소한 **로깅**은 추가: `logging.exception(...)` 또는 `print(..., file=sys.stderr)`로 한 줄이라도 남기기.
  - “예상되는 예외”(예: 파일 없음, JSON 파싱 실패)만 잡고, 그 외는 `raise`로 전파하거나, 상위에서 일괄 로깅하도록 구간별로 정리하는 것을 권장.

### 3.2 `category_table_io.load_category_table` 내부
- **현재**: xlsx 마이그레이션 시 `except Exception: pass`로 실패를 삼킴.
- **조언**: `FileNotFoundError`, `PermissionError`, `pd.errors.EmptyDataError` 등 **구체적 예외**만 잡고, 나머지는 로그 후 재발생시키거나, 실패 시 “마이그레이션 스킵”만 명시적으로 처리하도록 하는 편이 안전함.

---

## 4. 경로·입력 검증

### 4.1 `safe_write_category_table(path, df)` 호출 전
- **현재**: `apply_category_action` 등에서 `path`를 그대로 넘김. `_json_path`로 정규화되지만, `df`에 `CATEGORY_TABLE_COLUMNS`가 없을 수 있음.
- **조언**:  
  - `safe_write_category_table` 진입 시 `df`가 비어 있지 않다면 **필수 컬럼 존재 여부** 한 번 검사하고, 없으면 `KeyError` 또는 명시적 ValueError로 실패시키기.  
  - path는 이미 `_json_path` 후 None/빈 문자열 체크가 있으므로, “path는 정규화된 문자열만 넘기기” 규칙을 docstring에 적어 두면 좋음.

### 4.2 `get_category_table_path(project_root=None)`
- **현재**: `project_root`가 빈 문자열이면 `os.path.join('', '.source', ...)`로 상대 경로가 나올 수 있음.
- **조언**: `if project_root is not None and not str(project_root).strip():` 일 때는 `project_root=None`과 동일하게 처리하거나, 경로를 쓰기 전에 `os.path.normpath(os.path.abspath(...))`로 정규화해 두면 예기치 않은 현재 디렉터리 기준 경로를 줄일 수 있음.

---

## 5. JSON/파일 처리

### 5.1 `load_category_table` 마이그레이션 분기
- **현재**: `if not os.path.exists(path) or (os.path.exists(path) and os.path.getsize(path) == 0):` → 조건이 “없거나 크기 0”인데, 두 번째 `os.path.exists(path)`는 첫 번째가 False면 평가되지 않아 논리적으로는 맞지만, 가독성이 떨어짐.
- **조언**:  
  `file_missing_or_empty = not os.path.exists(path) or os.path.getsize(path) == 0`  
  같은 변수로 의도를 드러내고, 그 다음에 `if file_missing_or_empty:` 로 xlsx 마이그레이션 여부를 판단하면 읽기 쉬움.

### 5.2 JSON 저장 시 `df` 타입
- **현재**: `df[CATEGORY_TABLE_COLUMNS].copy().fillna('').to_dict('records')` 에서, `df`가 None이면 이미 상위에서 막혀 있어야 하나, 함수 서명만 보면 df가 None일 수 있음.
- **조언**: `safe_write_category_table` 맨 앞에서 `if df is None: raise ValueError("df is required")` 를 넣어 두면, 잘못된 호출을 빨리 잡을 수 있음.

---

## 6. process_bank_data 특이 사항

### 6.1 `migrate_bank_category_file` 실패 시 `_is_bad_zip_error(e)`
- **현재**: category_table이 **JSON**으로 바뀐 뒤에는 “zip/엑셀 손상” 오류가 나지 않음. 그런데도 `if not _is_bad_zip_error(e): print(...)` 로 분기해 둔 상태.
- **조언**:  
  - JSON 전용이면 “zip 오류” 분기는 제거하거나,  
  - “향후 xlsx 경로를 다시 지원할 수 있으니 유지”한다면 주석으로 “현재는 JSON만 사용하므로 이 분기는 거의 타지 않음”이라고 적어 두면, 나중에 보는 사람이 헷갈리지 않음.

### 6.2 `ensure_*` 내부의 `import shutil` ✅ 적용
- **적용 내용**: `process_bank_data.py` 상단에 `import shutil` 한 번 추가, 내부 인라인 제거.
- **조언(과거)**: 파일 상단이나 “백업/이동이 필요한 모듈” 상단에 `import shutil`을 한 번만 두고, 예외 블록에서는 사용만 하면 코드가 단순해짐.

---

## 7. 테스트·실행 검증

### 7.1 진입점 스크립트
- **조언**:  
  - `python -c "from category_constants import ...; from category_table_io import get_category_table, get_category_table_path; ..."` 처럼 **상수 → io → get_category_table(path)** 순으로 짧은 스크립트를 만들어 두고,  
  - “조회만 할 때는 반드시 `get_category_table(path)`를 써서 (df, existed) 로 받는다”는 규칙으로 실행해 보면, 앞서 말한 `load_category_table`/`get_category_table` 혼동을 줄일 수 있음.

### 7.2 `.source` 디렉터리
- **현재**: app.py에서 `.source`, `.source/Bank`, `.source/Card`만 생성. `.source/Cash`는 규칙에는 있으나 생성하지 않을 수 있음.
- **조언**: Cash 사용 시 오류를 막으려면, 앱 기동 시 또는 Cash 첫 사용 시 `.source/Cash`도 `makedirs(..., exist_ok=True)` 로 한 번 만들어 두는 것이 안전함. (이미 되어 있다면 유지.)

---

## 8. 요약 체크리스트

| 구분 | 조언 요약 |
|------|-----------|
| API | `load_category_table`(df만) / `get_category_table`(df, existed) 역할을 문서화하고, 호출부가 반환값을 잘못 풀어쓰지 않도록 규칙 정리 |
| 중복 | `ensure_all_bank_files`와 `ensure_bank_before_and_category`의 공통 부분을 한 함수로 묶기; process_* 폴백은 가능한 한 `category_table_fallback`으로 통일 |
| 예외 | `except Exception: pass`를 줄이고, 최소한 로그는 남기기; 가능한 구체적 예외만 처리 |
| 경로/입력 | `get_category_table_path`에서 빈 project_root 처리, `safe_write_category_table`에서 df/path 검증 강화 |
| 가독성 | `load_category_table`의 “없거나 크기 0” 조건을 변수로 분리; JSON 전용인 부분은 zip 관련 분기에 주석 추가 |
| 리소스 | `shutil` 등은 모듈 상단에서 한 번만 import |

위 항목을 순서대로 적용하면, “처음부터 실행했을 때” 동작은 유지하면서 유지보수성과 디버깅이 수월해집니다. (UX/UI 변경은 포함하지 않았습니다.)
