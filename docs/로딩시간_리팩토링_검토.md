# 로딩 시간 단축을 위한 리팩터링 검토

## 1. 현재 로딩 경로 요약

### 1.1 데이터 흐름
- **클라이언트**: `GET /bank|card|cash/api/category-applied-data` (또는 `processed-data`) 호출
- **서버**:
  1. 캐시 없으면 `load_category_file()` → `safe_read_data_json(path)` 로 **전체 파일 읽기 + json.load()**
  2. 필터(은행/날짜/계좌 등) 적용
  3. `df.to_dict('records')` → **전체 행을 list of dict로 변환**
  4. `_json_safe(data)` → **전체 재귀 순회** (NaN/NaT 등 치환)
  5. `jsonify({..., 'data': data})` → **한 번에 JSON 직렬화**
- **클라이언트**: `response.json()` 후 `data.data` 전체로 테이블 HTML 생성 → `innerHTML` 한 번 설정

### 1.2 병목 지점
| 구간 | 병목 | 데이터 규모에 따른 영향 |
|------|------|-------------------------|
| 파일 읽기 | `json.load(f)` 전체 로드 | 파일 크기 ∝ 메모리·파싱 시간 |
| 캐시 미스 | ensure + classify 등 | 첫 요청 시에만, 백그라운드·프리웜으로 상당 부분 완화됨 |
| 직렬화 | `to_dict('records')` + `_json_safe` + `json.dumps` | 행 수 ∝ CPU 시간 |
| 네트워크 | 한 번에 큰 JSON 전송 | 페이로드 크기 ∝ 전송 시간 |
| 클라이언트 | `JSON.parse` + 전체 행으로 HTML 문자열 생성 + DOM 한 번에 삽입 | 행 수 ∝ 파싱·렌더 시간 |

---

## 2. 적용된 개선 (현재 상태)
- 서버 기동 시 **백그라운드에서 bank/card/cash JSON 선행 생성** (Bank·Card 병렬)
- 백그라운드 완료 후 **캐시 프리웜**으로 각 앱 메모리 캐시 적재 → 첫 요청 시 파일 I/O 생략
- **캐시 정책**: 재생성 버튼 시에만 캐시 무효화, mtime 재검사 없음

---

## 3. 추가 리팩터링 제안

### 3.1 API 페이지네이션 (우선 추천)
**내용**: `category-applied-data` / `processed-data`에 `limit`·`offset`(또는 `page`·`page_size`) 지원.

- **서버**: 캐시에서 DataFrame 읽은 뒤, 필터 적용한 결과에 대해 `df.iloc[offset:offset+limit]`만 `to_dict('records')` + `_json_safe` 후 반환. `total`은 필터 후 전체 행 수로 반환.
- **클라이언트**: 첫 요청은 `limit=500` 등으로 작게 요청해 첫 화면만 빠르게 표시, 스크롤 시 추가 요청(또는 “더보기”)으로 이어받기.

**효과**: 첫 응답 크기·파싱·렌더 시간 감소, 체감 로딩 시간 단축.

**비용**: API 스펙 확장, 프론트에서 페이지/스크롤 처리 추가.

---

### 3.2 첫 화면만 빠르게 + 전체는 백그라운드 (변형)
**내용**: 첫 요청은 `limit=500`(또는 고정 작은 값)만 반환하고, 클라이언트에서 “전체 로드” 버튼 또는 자동으로 `limit=0`(또는 큰 값)으로 전체 재요청.

- **효과**: 첫 페이지만 빠르게 그리기, 나머지는 백그라운드에서 로드 가능.
- **비용**: 페이지네이션과 유사. “전체” 요청 시에는 여전히 큰 응답 한 번 발생.

---

### 3.3 JSON 파싱·직렬화 가속
**내용**:
- **읽기**: `json.load()` 대신 `orjson.loads()`(또는 `ujson`) 사용. (환경에 `orjson` 등 추가)
- **쓰기**: `json.dumps` 대신 `orjson.dumps()` 사용 시 직렬화 속도 향상.
- **저장 파일**: `data_json_io.safe_write_data_json`에서 `indent=2` 제거 시 파일 쓰기·크기 감소(읽기 시 파싱량도 소폭 감소).

**효과**: 대용량 JSON 기준 파싱·직렬화 시간 수~수십 % 단축 가능.

**비용**: 의존성 추가, 기존 `json` 사용처와 호환 유지 필요.

---

### 3.4 _json_safe 최소화
**내용**: `df.where(pd.notna(df), None)` 후 `to_dict('records')`만 하고, `_json_safe`를 생략하거나 “필요한 컬럼만 순회”하는 경량 치환으로 대체.

- **효과**: 대용량 `data` 리스트 전체 재귀 순회 제거 시 CPU 절감.
- **비용**: NaN/NaT/ numpy 타입이 그대로 나가면 JSON 직렬화 단계에서 예외 가능성 있으므로, 직렬화 직전에만 최소 치환하는 방식으로 설계 필요.

---

### 3.5 응답 압축 (Gzip)
**내용**: Flask `after_request`에서 응답 body를 gzip(또는 deflate)으로 압축해 전송.

- **효과**: JSON이 클 때 네트워크 전송량·전송 시간 감소.
- **비용**: 서버 CPU 소폭 증가, 클라이언트는 브라우저가 자동 해제.

---

### 3.6 클라이언트 가상 스크롤 (Virtual scroll)
**내용**: DOM에는 “보이는 구간 + 여유분”만 두고, 스크롤 시 데이터는 기존 `data.data` 배열에서 슬라이스해 행만 갱신.

- **효과**: 행 수가 많을 때 DOM 노드 수 감소, 스크롤·리플로우 부담 감소.
- **비용**: 여전히 전체 데이터를 한 번 받아야 하므로 “첫 로딩” 시간은 그대로. 첫 바이트까지 오는 시간은 페이지네이션으로 줄이는 편이 유리.

---

### 3.7 스트리밍 전송 (선택)
**내용**: `Transfer-Encoding: chunked`로 JSON 배열을 청크 단위로 보내고, 클라이언트에서 청크별로 파싱·행 추가.

- **효과**: 첫 청크 도착 후 바로 그리기 시작 가능, 체감 지연 감소.
- **비용**: API·프론트 양쪽 변경 폭이 크고, JSON 스트리밍 파싱(NDJSON 등) 설계 필요.

---

## 4. 우선순위 제안

| 순위 | 항목 | 기대 효과 | 구현 난이도 |
|------|------|-----------|-------------|
| 1 | API 페이지네이션 (limit/offset) | 첫 화면 로딩 시간 대폭 감소 | 중 |
| 2 | orjson 등으로 파싱·직렬화 가속 | 서버/클라이언트 처리 시간 감소 | 하 |
| 3 | 응답 Gzip | 대용량 시 전송 시간 감소 | 하 |
| 4 | _json_safe 최소화/경량화 | 서버 CPU·응답 생성 시간 감소 | 중 |
| 5 | 가상 스크롤 | 대량 행에서 스크롤·렌더 부담 감소 | 중 |
| 6 | 스트리밍 | 체감 지연 추가 감소 | 상 |

---

## 5. 정리
- **이미 적용**: 백그라운드 생성·캐시 프리웜·Bank/Card 병렬로 “첫 요청 시 파일 생성/읽기” 부담은 크게 줄어든 상태.
- **다음 단계로 유력한 것**: **페이지네이션**으로 첫 응답 크기와 파싱·렌더 양을 줄이고, 필요 시 **orjson + Gzip**으로 서버·전송 비용을 추가로 줄이는 구성이 균형이 좋음.

---

## 6. 추가 제안 (리팩터링 재검토)

아래는 1~4번 적용 이후 남은 개선 후보다.

| 제안 | 내용 | 효과 | 난이도 |
|------|------|------|--------|
| **Flask 응답 orjson** | 앱의 `jsonify()`가 사용하는 직렬화를 orjson으로 교체(JSONProvider). | API 응답 본문 생성 시간 감소 | 하 |
| **_json_safe 경량화** | list of dict만 한 번 순회하며 NaN/numpy/datetime만 치환. 재귀 제거. | 대용량 data 시 CPU 감소 | 중 |
| **processed-data 페이지네이션** | `get_processed_data`에도 limit/offset 지원. | 전처리후 테이블도 첫 화면만 빠르게 | 중 |
| **가상 스크롤** | 테이블 DOM에 보이는 구간만 렌더, 스크롤 시 슬라이스 갱신. | 1만 건 이상 시 스크롤·리플로우 부담 감소 | 중 |
| **저장 JSON indent 선택** | 대용량 저장 시 indent 없음 옵션(쓰기·파일 크기·읽기 소폭 개선). | 파일 I/O·파싱 소폭 개선 | 하 |
| **index 페이지 첫 요청 limit** | index의 카테고리 조회 첫 요청에 limit=1000 적용 후 나머지 백그라운드. | 첫 페이지만 빠르게 표시 | 하 |

우선 적용 권장: **Flask 응답 orjson**, **_json_safe 경량화**.
